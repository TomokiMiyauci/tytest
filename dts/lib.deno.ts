export const libDeno = `/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare interface ImportMeta{url:string;main:boolean;}declare interface Performance{mark(markName:string,options?:PerformanceMarkOptions):PerformanceMark;measure(measureName:string,options?:PerformanceMeasureOptions,):PerformanceMeasure;}declare interface PerformanceMarkOptions{detail?:any;startTime?:number;}declare interface PerformanceMeasureOptions{detail?:any;start?:string|number;duration?:number;end?:string|number;}declare namespace Deno{export namespace errors{export class NotFound extends Error{}export class PermissionDenied extends Error{}export class ConnectionRefused extends Error{}export class ConnectionReset extends Error{}export class ConnectionAborted extends Error{}export class NotConnected extends Error{}export class AddrInUse extends Error{}export class AddrNotAvailable extends Error{}export class BrokenPipe extends Error{}export class AlreadyExists extends Error{}export class InvalidData extends Error{}export class TimedOut extends Error{}export class Interrupted extends Error{}export class WriteZero extends Error{}export class UnexpectedEof extends Error{}export class BadResource extends Error{}export class Http extends Error{}export class Busy extends Error{}}export const pid:number;export const ppid:number;export interface MemoryUsage{rss:number;heapTotal:number;heapUsed:number;external:number;}export function memoryUsage():MemoryUsage;export const noColor:boolean;export interface TestContext{}export interface TestDefinition{fn:(t:TestContext)=>void|Promise<void>;name:string;ignore?:boolean;only?:boolean;sanitizeOps?:boolean;sanitizeResources?:boolean;sanitizeExit?:boolean;permissions?:"inherit"|"none"|{env?:"inherit"|boolean|string[];hrtime?:"inherit"|boolean;net?:"inherit"|boolean|string[];ffi?:"inherit"|boolean|Array<string|URL>;read?:"inherit"|boolean|Array<string|URL>;run?:"inherit"|boolean|Array<string|URL>;write?:"inherit"|boolean|Array<string|URL>;};}export function test(t:TestDefinition):void;export function test(name:string,fn:(t:TestContext)=>void|Promise<void>,):void;export function test(fn:(t:TestContext)=>void|Promise<void>):void;export function test(name:string,options:Omit<TestDefinition,"fn"|"name">,fn:(t:TestContext)=>void|Promise<void>,):void;export function test(options:Omit<TestDefinition,"fn">,fn:(t:TestContext)=>void|Promise<void>,):void;export function test(options:Omit<TestDefinition,"fn"|"name">,fn:(t:TestContext)=>void|Promise<void>,):void;export function exit(code?:number):never;export const env:{get(key:string):string|undefined;set(key:string,value:string):void;delete(key:string):void;toObject():{[index:string]:string};};export function execPath():string;export function chdir(directory:string|URL):void;export function cwd():string;export function linkSync(oldpath:string,newpath:string):void;export function link(oldpath:string,newpath:string):Promise<void>;export enum SeekMode{Start=0,Current=1,End=2,}export interface Reader{read(p:Uint8Array):Promise<number|null>;}export interface ReaderSync{readSync(p:Uint8Array):number|null;}export interface Writer{write(p:Uint8Array):Promise<number>;}export interface WriterSync{writeSync(p:Uint8Array):number;}export interface Closer{close():void;}export interface Seeker{seek(offset:number,whence:SeekMode):Promise<number>;}export interface SeekerSync{seekSync(offset:number,whence:SeekMode):number;}export function copy(src:Reader,dst:Writer,options?:{bufSize?:number;},):Promise<number>;export function iter(r:Reader,options?:{bufSize?:number;},):AsyncIterableIterator<Uint8Array>;export function iterSync(r:ReaderSync,options?:{bufSize?:number;},):IterableIterator<Uint8Array>;export function openSync(path:string|URL,options?:OpenOptions):File;export function open(path:string|URL,options?:OpenOptions,):Promise<File>;export function createSync(path:string|URL):File;export function create(path:string|URL):Promise<File>;export function readSync(rid:number,buffer:Uint8Array):number|null;export function read(rid:number,buffer:Uint8Array):Promise<number|null>;export function writeSync(rid:number,data:Uint8Array):number;export function write(rid:number,data:Uint8Array):Promise<number>;export function seekSync(rid:number,offset:number,whence:SeekMode,):number;export function seek(rid:number,offset:number,whence:SeekMode,):Promise<number>;export function fsyncSync(rid:number):void;export function fsync(rid:number):Promise<void>;export function fdatasyncSync(rid:number):void;export function fdatasync(rid:number):Promise<void>;export function close(rid:number):void;export class File implements
Reader,ReaderSync,Writer,WriterSync,Seeker,SeekerSync,Closer{readonly rid:number;constructor(rid:number);write(p:Uint8Array):Promise<number>;writeSync(p:Uint8Array):number;truncate(len?:number):Promise<void>;truncateSync(len?:number):void;read(p:Uint8Array):Promise<number|null>;readSync(p:Uint8Array):number|null;seek(offset:number,whence:SeekMode):Promise<number>;seekSync(offset:number,whence:SeekMode):number;stat():Promise<FileInfo>;statSync():FileInfo;close():void;}export const stdin:Reader&ReaderSync&Closer&{readonly rid:number};export const stdout:Writer&WriterSync&Closer&{readonly rid:number};export const stderr:Writer&WriterSync&Closer&{readonly rid:number};export interface OpenOptions{read?:boolean;write?:boolean;append?:boolean;truncate?:boolean;create?:boolean;createNew?:boolean;mode?:number;}export interface ReadFileOptions{signal?:AbortSignal;}export function isatty(rid:number):boolean;export class Buffer implements Reader,ReaderSync,Writer,WriterSync{constructor(ab?:ArrayBuffer);bytes(options?:{copy?:boolean}):Uint8Array;empty():boolean;readonly length:number;readonly capacity:number;truncate(n:number):void;reset():void;readSync(p:Uint8Array):number|null;read(p:Uint8Array):Promise<number|null>;writeSync(p:Uint8Array):number;write(p:Uint8Array):Promise<number>;grow(n:number):void;readFrom(r:Reader):Promise<number>;readFromSync(r:ReaderSync):number;}export function readAll(r:Reader):Promise<Uint8Array>;export function readAllSync(r:ReaderSync):Uint8Array;export function writeAll(w:Writer,arr:Uint8Array):Promise<void>;export function writeAllSync(w:WriterSync,arr:Uint8Array):void;export interface MkdirOptions{recursive?:boolean;mode?:number;}export function mkdirSync(path:string|URL,options?:MkdirOptions):void;export function mkdir(path:string|URL,options?:MkdirOptions,):Promise<void>;export interface MakeTempOptions{dir?:string;prefix?:string;suffix?:string;}export function makeTempDirSync(options?:MakeTempOptions):string;export function makeTempDir(options?:MakeTempOptions):Promise<string>;export function makeTempFileSync(options?:MakeTempOptions):string;export function makeTempFile(options?:MakeTempOptions):Promise<string>;export function chmodSync(path:string|URL,mode:number):void;export function chmod(path:string|URL,mode:number):Promise<void>;export function chownSync(path:string|URL,uid:number|null,gid:number|null,):void;export function chown(path:string|URL,uid:number|null,gid:number|null,):Promise<void>;export interface RemoveOptions{recursive?:boolean;}export function removeSync(path:string|URL,options?:RemoveOptions):void;export function remove(path:string|URL,options?:RemoveOptions,):Promise<void>;export function renameSync(oldpath:string|URL,newpath:string|URL,):void;export function rename(oldpath:string|URL,newpath:string|URL,):Promise<void>;export function readTextFileSync(path:string|URL):string;export function readTextFile(path:string|URL,options?:ReadFileOptions,):Promise<string>;export function readFileSync(path:string|URL):Uint8Array;export function readFile(path:string|URL,options?:ReadFileOptions,):Promise<Uint8Array>;export interface FileInfo{isFile:boolean;isDirectory:boolean;isSymlink:boolean;size:number;mtime:Date|null;atime:Date|null;birthtime:Date|null;dev:number|null;ino:number|null;mode:number|null;nlink:number|null;uid:number|null;gid:number|null;rdev:number|null;blksize:number|null;blocks:number|null;}export function realPathSync(path:string|URL):string;export function realPath(path:string|URL):Promise<string>;export interface DirEntry{name:string;isFile:boolean;isDirectory:boolean;isSymlink:boolean;}export function readDirSync(path:string|URL):Iterable<DirEntry>;export function readDir(path:string|URL):AsyncIterable<DirEntry>;export function copyFileSync(fromPath:string|URL,toPath:string|URL,):void;export function copyFile(fromPath:string|URL,toPath:string|URL,):Promise<void>;export function readLinkSync(path:string|URL):string;export function readLink(path:string|URL):Promise<string>;export function lstat(path:string|URL):Promise<FileInfo>;export function lstatSync(path:string|URL):FileInfo;export function stat(path:string|URL):Promise<FileInfo>;export function statSync(path:string|URL):FileInfo;export interface WriteFileOptions{append?:boolean;create?:boolean;mode?:number;signal?:AbortSignal;}export function writeFileSync(path:string|URL,data:Uint8Array,options?:WriteFileOptions,):void;export function writeFile(path:string|URL,data:Uint8Array,options?:WriteFileOptions,):Promise<void>;export function writeTextFileSync(path:string|URL,data:string,options?:WriteFileOptions,):void;export function writeTextFile(path:string|URL,data:string,options?:WriteFileOptions,):Promise<void>;export function truncateSync(name:string,len?:number):void;export function truncate(name:string,len?:number):Promise<void>;export interface OpMetrics{opsDispatched:number;opsDispatchedSync:number;opsDispatchedAsync:number;opsDispatchedAsyncUnref:number;opsCompleted:number;opsCompletedSync:number;opsCompletedAsync:number;opsCompletedAsyncUnref:number;bytesSentControl:number;bytesSentData:number;bytesReceived:number;}export interface Metrics extends OpMetrics{ops:Record<string,OpMetrics>;}export function metrics():Metrics;interface ResourceMap{[rid:number]:any;}export function resources():ResourceMap;export type FsEventFlag="rescan";export interface FsEvent{kind:"any"|"access"|"create"|"modify"|"remove"|"other";paths:string[];flag?:FsEventFlag;}export interface FsWatcher extends AsyncIterable<FsEvent>{readonly rid:number;close():void;return?(value?:any):Promise<IteratorResult<FsEvent>>;[Symbol.asyncIterator]():AsyncIterableIterator<FsEvent>;}export function watchFs(paths:string|string[],options?:{recursive:boolean},):FsWatcher;export class Process<T extends RunOptions=RunOptions>{readonly rid:number;readonly pid:number;readonly stdin:T["stdin"]extends"piped"?Writer&Closer:(Writer&Closer)|null;readonly stdout:T["stdout"]extends"piped"?Reader&Closer:(Reader&Closer)|null;readonly stderr:T["stderr"]extends"piped"?Reader&Closer:(Reader&Closer)|null;status():Promise<ProcessStatus>;output():Promise<Uint8Array>;stderrOutput():Promise<Uint8Array>;close():void;kill(signo:Signal):void;}export type Signal=|"SIGABRT"|"SIGALRM"|"SIGBUS"|"SIGCHLD"|"SIGCONT"|"SIGEMT"|"SIGFPE"|"SIGHUP"|"SIGILL"|"SIGINFO"|"SIGINT"|"SIGIO"|"SIGKILL"|"SIGPIPE"|"SIGPROF"|"SIGPWR"|"SIGQUIT"|"SIGSEGV"|"SIGSTKFLT"|"SIGSTOP"|"SIGSYS"|"SIGTERM"|"SIGTRAP"|"SIGTSTP"|"SIGTTIN"|"SIGTTOU"|"SIGURG"|"SIGUSR1"|"SIGUSR2"|"SIGVTALRM"|"SIGWINCH"|"SIGXCPU"|"SIGXFSZ";export type ProcessStatus=|{success:true;code:0;signal?:undefined;}|{success:false;code:number;signal?:number;};export interface RunOptions{cmd:string[]|[URL,...string[]];cwd?:string;env?:{[key:string]:string;};stdout?:"inherit"|"piped"|"null"|number;stderr?:"inherit"|"piped"|"null"|number;stdin?:"inherit"|"piped"|"null"|number;}export function run<T extends RunOptions=RunOptions>(opt:T):Process<T>;export interface InspectOptions{colors?:boolean;compact?:boolean;depth?:number;iterableLimit?:number;showProxy?:boolean;sorted?:boolean;trailingComma?:boolean;getters?:boolean;showHidden?:boolean;}export function inspect(value:unknown,options?:InspectOptions):string;export type PermissionName=|"run"|"read"|"write"|"net"|"env"|"ffi"|"hrtime";export type PermissionState="granted"|"denied"|"prompt";export interface RunPermissionDescriptor{name:"run";command?:string|URL;}export interface ReadPermissionDescriptor{name:"read";path?:string|URL;}export interface WritePermissionDescriptor{name:"write";path?:string|URL;}export interface NetPermissionDescriptor{name:"net";host?:string;}export interface EnvPermissionDescriptor{name:"env";variable?:string;}export interface FfiPermissionDescriptor{name:"ffi";path?:string|URL;}export interface HrtimePermissionDescriptor{name:"hrtime";}export type PermissionDescriptor=|RunPermissionDescriptor|ReadPermissionDescriptor|WritePermissionDescriptor|NetPermissionDescriptor|EnvPermissionDescriptor|FfiPermissionDescriptor|HrtimePermissionDescriptor;export interface PermissionStatusEventMap{"change":Event;}export class PermissionStatus extends EventTarget{onchange:((this:PermissionStatus,ev:Event)=>any)|null;readonly state:PermissionState;addEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K],)=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K],)=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;}export class Permissions{query(desc:PermissionDescriptor):Promise<PermissionStatus>;revoke(desc:PermissionDescriptor):Promise<PermissionStatus>;request(desc:PermissionDescriptor):Promise<PermissionStatus>;}export const permissions:Permissions;export const build:{target:string;arch:"x86_64"|"aarch64";os:"darwin"|"linux"|"windows";vendor:string;env?:string;};export const version:{deno:string;v8:string;typescript:string;};export const args:string[];export const customInspect:unique symbol;export const mainModule:string;export type SymlinkOptions={type:"file"|"dir";};export function symlinkSync(oldpath:string|URL,newpath:string|URL,options?:SymlinkOptions,):void;export function symlink(oldpath:string|URL,newpath:string|URL,options?:SymlinkOptions,):Promise<void>;export function ftruncateSync(rid:number,len?:number):void;export function ftruncate(rid:number,len?:number):Promise<void>;export function fstatSync(rid:number):FileInfo;export function fstat(rid:number):Promise<FileInfo>;export interface RequestEvent{readonly request:Request;respondWith(r:Response|Promise<Response>):Promise<void>;}export interface HttpConn extends AsyncIterable<RequestEvent>{readonly rid:number;nextRequest():Promise<RequestEvent|null>;close():void;}export function serveHttp(conn:Conn):HttpConn;export interface WebSocketUpgrade{response:Response;socket:WebSocket;}export interface UpgradeWebSocketOptions{protocol?:string;}export function upgradeWebSocket(request:Request,options?:UpgradeWebSocketOptions,):WebSocketUpgrade;export function kill(pid:number,signo:Signal):void;export type RecordType=|"A"|"AAAA"|"ANAME"|"CNAME"|"MX"|"PTR"|"SRV"|"TXT";export interface ResolveDnsOptions{nameServer?:{ipAddr:string;port?:number;};}export interface MXRecord{preference:number;exchange:string;}export interface SRVRecord{priority:number;weight:number;port:number;target:string;}export function resolveDns(query:string,recordType:"A"|"AAAA"|"ANAME"|"CNAME"|"PTR",options?:ResolveDnsOptions,):Promise<string[]>;export function resolveDns(query:string,recordType:"MX",options?:ResolveDnsOptions,):Promise<MXRecord[]>;export function resolveDns(query:string,recordType:"SRV",options?:ResolveDnsOptions,):Promise<SRVRecord[]>;export function resolveDns(query:string,recordType:"TXT",options?:ResolveDnsOptions,):Promise<string[][]>;export function resolveDns(query:string,recordType:RecordType,options?:ResolveDnsOptions,):Promise<string[]|MXRecord[]|SRVRecord[]|string[][]>;}/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare interface Console{assert(condition?:boolean,...data:any[]):void;clear():void;count(label?:string):void;countReset(label?:string):void;debug(...data:any[]):void;dir(item?:any,options?:any):void;dirxml(...data:any[]):void;error(...data:any[]):void;group(...data:any[]):void;groupCollapsed(...data:any[]):void;groupEnd():void;info(...data:any[]):void;log(...data:any[]):void;table(tabularData?:any,properties?:string[]):void;time(label?:string):void;timeEnd(label?:string):void;timeLog(label?:string,...data:any[]):void;trace(...data:any[]):void;warn(...data:any[]):void;}/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare class URLSearchParams{constructor(init?:string[][]|Record<string,string>|string|URLSearchParams,);static toString():string;append(name:string,value:string):void;delete(name:string):void;getAll(name:string):string[];get(name:string):string|null;has(name:string):boolean;set(name:string,value:string):void;sort():void;forEach(callbackfn:(value:string,key:string,parent:this)=>void,thisArg?:any,):void;keys():IterableIterator<string>;values():IterableIterator<string>;entries():IterableIterator<[string,string]>;[Symbol.iterator]():IterableIterator<[string,string]>;toString():string;}declare class URL{constructor(url:string,base?:string|URL);static createObjectURL(blob:Blob):string;static revokeObjectURL(url:string):void;hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;password:string;pathname:string;port:string;protocol:string;search:string;readonly searchParams:URLSearchParams;username:string;toJSON():string;}declare interface URLPatternInit{protocol?:string;username?:string;password?:string;hostname?:string;port?:string;pathname?:string;search?:string;hash?:string;baseURL?:string;}declare type URLPatternInput=string|URLPatternInit;declare interface URLPatternComponentResult{input:string;groups:Record<string,string>;}declare interface URLPatternResult{inputs:[URLPatternInit]|[URLPatternInit,string];protocol:URLPatternComponentResult;username:URLPatternComponentResult;password:URLPatternComponentResult;hostname:URLPatternComponentResult;port:URLPatternComponentResult;pathname:URLPatternComponentResult;search:URLPatternComponentResult;hash:URLPatternComponentResult;}declare class URLPattern{constructor(input:URLPatternInput,baseURL?:string);test(input:URLPatternInput,baseURL?:string):boolean;exec(input:URLPatternInput,baseURL?:string):URLPatternResult|null;readonly protocol:string;readonly username:string;readonly password:string;readonly hostname:string;readonly port:string;readonly pathname:string;readonly search:string;readonly hash:string;}/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare class DOMException extends Error{constructor(message?:string,name?:string);readonly name:string;readonly message:string;readonly code:number;}interface EventInit{bubbles?:boolean;cancelable?:boolean;composed?:boolean;}declare class Event{constructor(type:string,eventInitDict?:EventInit);readonly bubbles:boolean;cancelBubble:boolean;readonly cancelable:boolean;readonly composed:boolean;readonly currentTarget:EventTarget|null;readonly defaultPrevented:boolean;readonly eventPhase:number;readonly isTrusted:boolean;readonly target:EventTarget|null;readonly timeStamp:number;readonly type:string;composedPath():EventTarget[];preventDefault():void;stopImmediatePropagation():void;stopPropagation():void;readonly AT_TARGET:number;readonly BUBBLING_PHASE:number;readonly CAPTURING_PHASE:number;readonly NONE:number;static readonly AT_TARGET:number;static readonly BUBBLING_PHASE:number;static readonly CAPTURING_PHASE:number;static readonly NONE:number;}declare class EventTarget{addEventListener(type:string,listener:EventListenerOrEventListenerObject|null,options?:boolean|AddEventListenerOptions,):void;dispatchEvent(event:Event):boolean;removeEventListener(type:string,callback:EventListenerOrEventListenerObject|null,options?:EventListenerOptions|boolean,):void;}interface EventListener{(evt:Event):void|Promise<void>;}interface EventListenerObject{handleEvent(evt:Event):void|Promise<void>;}declare type EventListenerOrEventListenerObject=|EventListener|EventListenerObject;interface AddEventListenerOptions extends EventListenerOptions{once?:boolean;passive?:boolean;}interface EventListenerOptions{capture?:boolean;}interface ProgressEventInit extends EventInit{lengthComputable?:boolean;loaded?:number;total?:number;}declare class ProgressEvent<T extends EventTarget=EventTarget>extends Event{constructor(type:string,eventInitDict?:ProgressEventInit);readonly lengthComputable:boolean;readonly loaded:number;readonly target:T|null;readonly total:number;}declare function atob(s:string):string;declare function btoa(s:string):string;declare interface TextDecoderOptions{fatal?:boolean;ignoreBOM?:boolean;}declare interface TextDecodeOptions{stream?:boolean;}interface TextDecoder{readonly encoding:string;readonly fatal:boolean;readonly ignoreBOM:boolean;decode(input?:BufferSource,options?:TextDecodeOptions):string;}declare var TextDecoder:{prototype:TextDecoder;new(label?:string,options?:TextDecoderOptions):TextDecoder;};declare interface TextEncoderEncodeIntoResult{read:number;written:number;}interface TextEncoder{readonly encoding:"utf-8";encode(input?:string):Uint8Array;encodeInto(input:string,dest:Uint8Array):TextEncoderEncodeIntoResult;}declare var TextEncoder:{prototype:TextEncoder;new():TextEncoder;};interface TextDecoderStream{readonly encoding:string;readonly fatal:boolean;readonly ignoreBOM:boolean;readonly readable:ReadableStream<string>;readonly writable:WritableStream<BufferSource>;readonly[Symbol.toStringTag]:string;}declare var TextDecoderStream:{prototype:TextDecoderStream;new(label?:string,options?:TextDecoderOptions):TextDecoderStream;};interface TextEncoderStream{readonly encoding:"utf-8";readonly readable:ReadableStream<Uint8Array>;readonly writable:WritableStream<string>;readonly[Symbol.toStringTag]:string;}declare var TextEncoderStream:{prototype:TextEncoderStream;new():TextEncoderStream;};declare class AbortController{readonly signal:AbortSignal;abort(reason?:any):void;}interface AbortSignalEventMap{abort:Event;}interface AbortSignal extends EventTarget{readonly aborted:boolean;readonly reason?:unknown;onabort:((this:AbortSignal,ev:Event)=>any)|null;addEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;throwIfAborted():void;}declare var AbortSignal:{prototype:AbortSignal;new():AbortSignal;abort(reason?:any):AbortSignal;};interface FileReaderEventMap{"abort":ProgressEvent<FileReader>;"error":ProgressEvent<FileReader>;"load":ProgressEvent<FileReader>;"loadend":ProgressEvent<FileReader>;"loadstart":ProgressEvent<FileReader>;"progress":ProgressEvent<FileReader>;}interface FileReader extends EventTarget{readonly error:DOMException|null;onabort:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onerror:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onload:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadend:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadstart:|((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onprogress:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;readonly readyState:number;readonly result:string|ArrayBuffer|null;abort():void;readAsArrayBuffer(blob:Blob):void;readAsBinaryString(blob:Blob):void;readAsDataURL(blob:Blob):void;readAsText(blob:Blob,encoding?:string):void;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;addEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;}declare var FileReader:{prototype:FileReader;new():FileReader;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;};type BlobPart=BufferSource|Blob|string;interface BlobPropertyBag{type?:string;endings?:"transparent"|"native";}declare class Blob{constructor(blobParts?:BlobPart[],options?:BlobPropertyBag);readonly size:number;readonly type:string;arrayBuffer():Promise<ArrayBuffer>;slice(start?:number,end?:number,contentType?:string):Blob;stream():ReadableStream<Uint8Array>;text():Promise<string>;}interface FilePropertyBag extends BlobPropertyBag{lastModified?:number;}declare class File extends Blob{constructor(fileBits:BlobPart[],fileName:string,options?:FilePropertyBag,);readonly lastModified:number;readonly name:string;}interface ReadableStreamReadDoneResult<T>{done:true;value?:T;}interface ReadableStreamReadValueResult<T>{done:false;value:T;}type ReadableStreamReadResult<T>=|ReadableStreamReadValueResult<T>|ReadableStreamReadDoneResult<T>;interface ReadableStreamDefaultReader<R=any>{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}interface ReadableStreamBYOBReadDoneResult<V extends ArrayBufferView>{done:true;value?:V;}interface ReadableStreamBYOBReadValueResult<V extends ArrayBufferView>{done:false;value:V;}type ReadableStreamBYOBReadResult<V extends ArrayBufferView>=|ReadableStreamBYOBReadDoneResult<V>|ReadableStreamBYOBReadValueResult<V>;interface ReadableStreamBYOBReader{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read<V extends ArrayBufferView>(view:V,):Promise<ReadableStreamBYOBReadResult<V>>;releaseLock():void;}interface ReadableStreamBYOBRequest{readonly view:ArrayBufferView|null;respond(bytesWritten:number):void;respondWithNewView(view:ArrayBufferView):void;}declare var ReadableStreamDefaultReader:{prototype:ReadableStreamDefaultReader;new<R>(stream:ReadableStream<R>):ReadableStreamDefaultReader<R>;};interface ReadableStreamReader<R=any>{cancel():Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}declare var ReadableStreamReader:{prototype:ReadableStreamReader;new():ReadableStreamReader;};interface ReadableByteStreamControllerCallback{(controller:ReadableByteStreamController):void|PromiseLike<void>;}interface UnderlyingByteSource{autoAllocateChunkSize?:number;cancel?:ReadableStreamErrorCallback;pull?:ReadableByteStreamControllerCallback;start?:ReadableByteStreamControllerCallback;type:"bytes";}interface UnderlyingSink<W=any>{abort?:WritableStreamErrorCallback;close?:WritableStreamDefaultControllerCloseCallback;start?:WritableStreamDefaultControllerStartCallback;type?:undefined;write?:WritableStreamDefaultControllerWriteCallback<W>;}interface UnderlyingSource<R=any>{cancel?:ReadableStreamErrorCallback;pull?:ReadableStreamDefaultControllerCallback<R>;start?:ReadableStreamDefaultControllerCallback<R>;type?:undefined;}interface ReadableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}interface ReadableStreamDefaultControllerCallback<R>{(controller:ReadableStreamDefaultController<R>):void|PromiseLike<void>;}interface ReadableStreamDefaultController<R=any>{readonly desiredSize:number|null;close():void;enqueue(chunk:R):void;error(error?:any):void;}declare var ReadableStreamDefaultController:{prototype:ReadableStreamDefaultController;new():ReadableStreamDefaultController;};interface ReadableByteStreamController{readonly byobRequest:ReadableStreamBYOBRequest|null;readonly desiredSize:number|null;close():void;enqueue(chunk:ArrayBufferView):void;error(error?:any):void;}declare var ReadableByteStreamController:{prototype:ReadableByteStreamController;new():ReadableByteStreamController;};interface PipeOptions{preventAbort?:boolean;preventCancel?:boolean;preventClose?:boolean;signal?:AbortSignal;}interface QueuingStrategySizeCallback<T=any>{(chunk:T):number;}interface QueuingStrategy<T=any>{highWaterMark?:number;size?:QueuingStrategySizeCallback<T>;}interface CountQueuingStrategy extends QueuingStrategy{highWaterMark:number;size(chunk:any):1;}declare var CountQueuingStrategy:{prototype:CountQueuingStrategy;new(options:{highWaterMark:number}):CountQueuingStrategy;};interface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView>{highWaterMark:number;size(chunk:ArrayBufferView):number;}declare var ByteLengthQueuingStrategy:{prototype:ByteLengthQueuingStrategy;new(options:{highWaterMark:number}):ByteLengthQueuingStrategy;};interface ReadableStream<R=any>{readonly locked:boolean;cancel(reason?:any):Promise<void>;getReader(options:{mode:"byob"}):ReadableStreamBYOBReader;getReader(options?:{mode?:undefined}):ReadableStreamDefaultReader<R>;pipeThrough<T>({writable,readable}:{writable:WritableStream<R>;readable:ReadableStream<T>;},options?:PipeOptions,):ReadableStream<T>;pipeTo(dest:WritableStream<R>,options?:PipeOptions):Promise<void>;tee():[ReadableStream<R>,ReadableStream<R>];[Symbol.asyncIterator](options?:{preventCancel?:boolean;}):AsyncIterableIterator<R>;}declare var ReadableStream:{prototype:ReadableStream;new(underlyingSource:UnderlyingByteSource,strategy?:{highWaterMark?:number;size?:undefined},):ReadableStream<Uint8Array>;new<R=any>(underlyingSource?:UnderlyingSource<R>,strategy?:QueuingStrategy<R>,):ReadableStream<R>;};interface WritableStreamDefaultControllerCloseCallback{():void|PromiseLike<void>;}interface WritableStreamDefaultControllerStartCallback{(controller:WritableStreamDefaultController):void|PromiseLike<void>;}interface WritableStreamDefaultControllerWriteCallback<W>{(chunk:W,controller:WritableStreamDefaultController):|void|PromiseLike<void>;}interface WritableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}interface WritableStream<W=any>{readonly locked:boolean;abort(reason?:any):Promise<void>;getWriter():WritableStreamDefaultWriter<W>;}declare var WritableStream:{prototype:WritableStream;new<W=any>(underlyingSink?:UnderlyingSink<W>,strategy?:QueuingStrategy<W>,):WritableStream<W>;};interface WritableStreamDefaultController{signal:AbortSignal;error(error?:any):void;}declare var WritableStreamDefaultController:WritableStreamDefaultController;interface WritableStreamDefaultWriter<W=any>{readonly closed:Promise<void>;readonly desiredSize:number|null;readonly ready:Promise<void>;abort(reason?:any):Promise<void>;close():Promise<void>;releaseLock():void;write(chunk:W):Promise<void>;}declare var WritableStreamDefaultWriter:{prototype:WritableStreamDefaultWriter;new():WritableStreamDefaultWriter;};interface TransformStream<I=any,O=any>{readonly readable:ReadableStream<O>;readonly writable:WritableStream<I>;}declare var TransformStream:{prototype:TransformStream;new<I=any,O=any>(transformer?:Transformer<I,O>,writableStrategy?:QueuingStrategy<I>,readableStrategy?:QueuingStrategy<O>,):TransformStream<I,O>;};interface TransformStreamDefaultController<O=any>{readonly desiredSize:number|null;enqueue(chunk:O):void;error(reason?:any):void;terminate():void;}declare var TransformStreamDefaultController:TransformStreamDefaultController;interface Transformer<I=any,O=any>{flush?:TransformStreamDefaultControllerCallback<O>;readableType?:undefined;start?:TransformStreamDefaultControllerCallback<O>;transform?:TransformStreamDefaultControllerTransformCallback<I,O>;writableType?:undefined;}interface TransformStreamDefaultControllerCallback<O>{(controller:TransformStreamDefaultController<O>):void|PromiseLike<void>;}interface TransformStreamDefaultControllerTransformCallback<I,O>{(chunk:I,controller:TransformStreamDefaultController<O>,):void|PromiseLike<void>;}interface MessageEventInit<T=any>extends EventInit{data?:T;origin?:string;lastEventId?:string;}declare class MessageEvent<T=any>extends Event{readonly data:T;readonly lastEventId:string;readonly ports:ReadonlyArray<MessagePort>;constructor(type:string,eventInitDict?:MessageEventInit);}type Transferable=ArrayBuffer|MessagePort;type PostMessageOptions=StructuredSerializeOptions;interface StructuredSerializeOptions{transfer?:Transferable[];}declare class MessageChannel{constructor();readonly port1:MessagePort;readonly port2:MessagePort;}interface MessagePortEventMap{"message":MessageEvent;"messageerror":MessageEvent;}declare class MessagePort extends EventTarget{onmessage:((this:MessagePort,ev:MessageEvent)=>any)|null;onmessageerror:((this:MessagePort,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:StructuredSerializeOptions):void;start():void;addEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;}declare function structuredClone(value:any,options?:StructuredSerializeOptions,):any;/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
interface DomIterable<K,V>{keys():IterableIterator<K>;values():IterableIterator<V>;entries():IterableIterator<[K,V]>;[Symbol.iterator]():IterableIterator<[K,V]>;forEach(callback:(value:V,key:K,parent:this)=>void,thisArg?:any,):void;}type FormDataEntryValue=File|string;interface FormData{append(name:string,value:string|Blob,fileName?:string):void;delete(name:string):void;get(name:string):FormDataEntryValue|null;getAll(name:string):FormDataEntryValue[];has(name:string):boolean;set(name:string,value:string|Blob,fileName?:string):void;keys():IterableIterator<string>;values():IterableIterator<string>;entries():IterableIterator<[string,FormDataEntryValue]>;[Symbol.iterator]():IterableIterator<[string,FormDataEntryValue]>;forEach(callback:(value:FormDataEntryValue,key:string,parent:this)=>void,thisArg?:any,):void;}declare var FormData:{prototype:FormData;new():FormData;};interface Body{readonly body:ReadableStream<Uint8Array>|null;readonly bodyUsed:boolean;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any>;text():Promise<string>;}type HeadersInit=Headers|string[][]|Record<string,string>;interface Headers{append(name:string,value:string):void;delete(name:string):void;get(name:string):string|null;has(name:string):boolean;set(name:string,value:string):void;forEach(callbackfn:(value:string,key:string,parent:Headers)=>void,thisArg?:any,):void;}declare class Headers implements DomIterable<string,string>{constructor(init?:HeadersInit);append(name:string,value:string):void;delete(name:string):void;entries():IterableIterator<[string,string]>;get(name:string):string|null;has(name:string):boolean;keys():IterableIterator<string>;set(name:string,value:string):void;values():IterableIterator<string>;forEach(callbackfn:(value:string,key:string,parent:this)=>void,thisArg?:any,):void;[Symbol.iterator]():IterableIterator<[string,string]>;}type RequestInfo=Request|string;type RequestCache=|"default"|"force-cache"|"no-cache"|"no-store"|"only-if-cached"|"reload";type RequestCredentials="include"|"omit"|"same-origin";type RequestMode="cors"|"navigate"|"no-cors"|"same-origin";type RequestRedirect="error"|"follow"|"manual";type ReferrerPolicy=|""|"no-referrer"|"no-referrer-when-downgrade"|"origin"|"origin-when-cross-origin"|"same-origin"|"strict-origin"|"strict-origin-when-cross-origin"|"unsafe-url";type BodyInit=|Blob|BufferSource|FormData|URLSearchParams|ReadableStream<Uint8Array>|string;type RequestDestination=|""|"audio"|"audioworklet"|"document"|"embed"|"font"|"image"|"manifest"|"object"|"paintworklet"|"report"|"script"|"sharedworker"|"style"|"track"|"video"|"worker"|"xslt";interface RequestInit{body?:BodyInit|null;cache?:RequestCache;credentials?:RequestCredentials;headers?:HeadersInit;integrity?:string;keepalive?:boolean;method?:string;mode?:RequestMode;redirect?:RequestRedirect;referrer?:string;referrerPolicy?:ReferrerPolicy;signal?:AbortSignal|null;window?:any;}declare class Request implements Body{constructor(input:RequestInfo,init?:RequestInit);readonly cache:RequestCache;readonly credentials:RequestCredentials;readonly destination:RequestDestination;readonly headers:Headers;readonly integrity:string;readonly isHistoryNavigation:boolean;readonly isReloadNavigation:boolean;readonly keepalive:boolean;readonly method:string;readonly mode:RequestMode;readonly redirect:RequestRedirect;readonly referrer:string;readonly referrerPolicy:ReferrerPolicy;readonly signal:AbortSignal;readonly url:string;clone():Request;readonly body:ReadableStream<Uint8Array>|null;readonly bodyUsed:boolean;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any>;text():Promise<string>;}interface ResponseInit{headers?:HeadersInit;status?:number;statusText?:string;}type ResponseType=|"basic"|"cors"|"default"|"error"|"opaque"|"opaqueredirect";declare class Response implements Body{constructor(body?:BodyInit|null,init?:ResponseInit);static error():Response;static redirect(url:string,status?:number):Response;readonly headers:Headers;readonly ok:boolean;readonly redirected:boolean;readonly status:number;readonly statusText:string;readonly trailer:Promise<Headers>;readonly type:ResponseType;readonly url:string;clone():Response;readonly body:ReadableStream<Uint8Array>|null;readonly bodyUsed:boolean;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any>;text():Promise<string>;}declare function fetch(input:Request|URL|string,init?:RequestInit,):Promise<Response>;/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
interface GPUObjectBase{label:string|null;}declare interface GPUObjectDescriptorBase{label?:string;}declare class GPUSupportedLimits{maxTextureDimension1D?:number;maxTextureDimension2D?:number;maxTextureDimension3D?:number;maxTextureArrayLayers?:number;maxBindGroups?:number;maxDynamicUniformBuffersPerPipelineLayout?:number;maxDynamicStorageBuffersPerPipelineLayout?:number;maxSampledTexturesPerShaderStage?:number;maxSamplersPerShaderStage?:number;maxStorageBuffersPerShaderStage?:number;maxStorageTexturesPerShaderStage?:number;maxUniformBuffersPerShaderStage?:number;maxUniformBufferBindingSize?:number;maxStorageBufferBindingSize?:number;minUniformBufferOffsetAlignment?:number;minStorageBufferOffsetAlignment?:number;maxVertexBuffers?:number;maxVertexAttributes?:number;maxVertexBufferArrayStride?:number;maxInterStageShaderComponents?:number;maxComputeWorkgroupStorageSize?:number;maxComputeInvocationsPerWorkgroup?:number;maxComputeWorkgroupSizeX?:number;maxComputeWorkgroupSizeY?:number;maxComputeWorkgroupSizeZ?:number;maxComputeWorkgroupsPerDimension?:number;}declare class GPUSupportedFeatures{forEach(callbackfn:(value:GPUFeatureName,value2:GPUFeatureName,set:Set<GPUFeatureName>,)=>void,thisArg?:any,):void;has(value:GPUFeatureName):boolean;size:number;[
Symbol.iterator]():IterableIterator<GPUFeatureName>;entries():IterableIterator<[GPUFeatureName,GPUFeatureName]>;keys():IterableIterator<GPUFeatureName>;values():IterableIterator<GPUFeatureName>;}declare class GPU{requestAdapter(options?:GPURequestAdapterOptions,):Promise<GPUAdapter|null>;}declare interface GPURequestAdapterOptions{powerPreference?:GPUPowerPreference;forceFallbackAdapter?:boolean;}declare type GPUPowerPreference="low-power"|"high-performance";declare class GPUAdapter{readonly name:string;readonly features:GPUSupportedFeatures;readonly limits:GPUSupportedLimits;readonly isFallbackAdapter:boolean;requestDevice(descriptor?:GPUDeviceDescriptor):Promise<GPUDevice>;}declare interface GPUDeviceDescriptor extends GPUObjectDescriptorBase{requiredFeatures?:GPUFeatureName[];requiredLimits?:Record<string,number>;}declare type GPUFeatureName=|"depth-clamping"|"depth24unorm-stencil8"|"depth32float-stencil8"|"pipeline-statistics-query"|"texture-compression-bc"|"timestamp-query"|"mappable-primary-buffers"|"sampled-texture-binding-array"|"sampled-texture-array-dynamic-indexing"|"sampled-texture-array-non-uniform-indexing"|"unsized-binding-array"|"multi-draw-indirect"|"multi-draw-indirect-count"|"push-constants"|"address-mode-clamp-to-border"|"non-fill-polygon-mode"|"texture-compression-etc2"|"texture-compression-astc-ldr"|"texture-adapter-specific-format-features"|"shader-float64"|"vertex-attribute-64bit";declare class GPUDevice extends EventTarget implements GPUObjectBase{label:string|null;readonly lost:Promise<GPUDeviceLostInfo>;pushErrorScope(filter:GPUErrorFilter):undefined;popErrorScope():Promise<GPUError|null>;onuncapturederror:|((this:GPUDevice,ev:GPUUncapturedErrorEvent)=>any)|null;readonly features:ReadonlyArray<GPUFeatureName>;readonly limits:Record<string,number>;readonly queue:GPUQueue;destroy():undefined;createBuffer(descriptor:GPUBufferDescriptor):GPUBuffer;createTexture(descriptor:GPUTextureDescriptor):GPUTexture;createSampler(descriptor?:GPUSamplerDescriptor):GPUSampler;createBindGroupLayout(descriptor:GPUBindGroupLayoutDescriptor,):GPUBindGroupLayout;createPipelineLayout(descriptor:GPUPipelineLayoutDescriptor,):GPUPipelineLayout;createBindGroup(descriptor:GPUBindGroupDescriptor):GPUBindGroup;createShaderModule(descriptor:GPUShaderModuleDescriptor):GPUShaderModule;createComputePipeline(descriptor:GPUComputePipelineDescriptor,):GPUComputePipeline;createRenderPipeline(descriptor:GPURenderPipelineDescriptor,):GPURenderPipeline;createComputePipelineAsync(descriptor:GPUComputePipelineDescriptor,):Promise<GPUComputePipeline>;createRenderPipelineAsync(descriptor:GPURenderPipelineDescriptor,):Promise<GPURenderPipeline>;createCommandEncoder(descriptor?:GPUCommandEncoderDescriptor,):GPUCommandEncoder;createRenderBundleEncoder(descriptor:GPURenderBundleEncoderDescriptor,):GPURenderBundleEncoder;createQuerySet(descriptor:GPUQuerySetDescriptor):GPUQuerySet;}declare class GPUBuffer implements GPUObjectBase{label:string|null;mapAsync(mode:GPUMapModeFlags,offset?:number,size?:number,):Promise<undefined>;getMappedRange(offset?:number,size?:number):ArrayBuffer;unmap():undefined;destroy():undefined;}declare interface GPUBufferDescriptor extends GPUObjectDescriptorBase{size:number;usage:GPUBufferUsageFlags;mappedAtCreation?:boolean;}declare type GPUBufferUsageFlags=number;declare class GPUBufferUsage{static MAP_READ:0x0001;static MAP_WRITE:0x0002;static COPY_SRC:0x0004;static COPY_DST:0x0008;static INDEX:0x0010;static VERTEX:0x0020;static UNIFORM:0x0040;static STORAGE:0x0080;static INDIRECT:0x0100;static QUERY_RESOLVE:0x0200;}declare type GPUMapModeFlags=number;declare class GPUMapMode{static READ:0x0001;static WRITE:0x0002;}declare class GPUTexture implements GPUObjectBase{label:string|null;createView(descriptor?:GPUTextureViewDescriptor):GPUTextureView;destroy():undefined;}declare interface GPUTextureDescriptor extends GPUObjectDescriptorBase{size:GPUExtent3D;mipLevelCount?:number;sampleCount?:number;dimension?:GPUTextureDimension;format:GPUTextureFormat;usage:GPUTextureUsageFlags;}declare type GPUTextureDimension="1d"|"2d"|"3d";declare type GPUTextureUsageFlags=number;declare class GPUTextureUsage{static COPY_SRC:0x01;static COPY_DST:0x02;static TEXTURE_BINDING:0x04;static STORAGE_BINDING:0x08;static RENDER_ATTACHMENT:0x10;}declare class GPUTextureView implements GPUObjectBase{label:string|null;}declare interface GPUTextureViewDescriptor extends GPUObjectDescriptorBase{format?:GPUTextureFormat;dimension?:GPUTextureViewDimension;aspect?:GPUTextureAspect;baseMipLevel?:number;mipLevelCount?:number;baseArrayLayer?:number;arrayLayerCount?:number;}declare type GPUTextureViewDimension=|"1d"|"2d"|"2d-array"|"cube"|"cube-array"|"3d";declare type GPUTextureAspect="all"|"stencil-only"|"depth-only";declare type GPUTextureFormat=|"r8unorm"|"r8snorm"|"r8uint"|"r8sint"|"r16uint"|"r16sint"|"r16float"|"rg8unorm"|"rg8snorm"|"rg8uint"|"rg8sint"|"r32uint"|"r32sint"|"r32float"|"rg16uint"|"rg16sint"|"rg16float"|"rgba8unorm"|"rgba8unorm-srgb"|"rgba8snorm"|"rgba8uint"|"rgba8sint"|"bgra8unorm"|"bgra8unorm-srgb"|"rgb9e5ufloat"|"rgb10a2unorm"|"rg11b10ufloat"|"rg32uint"|"rg32sint"|"rg32float"|"rgba16uint"|"rgba16sint"|"rgba16float"|"rgba32uint"|"rgba32sint"|"rgba32float"|"stencil8"|"depth16unorm"|"depth24plus"|"depth24plus-stencil8"|"depth32float"|"bc1-rgba-unorm"|"bc1-rgba-unorm-srgb"|"bc2-rgba-unorm"|"bc2-rgba-unorm-srgb"|"bc3-rgba-unorm"|"bc3-rgba-unorm-srgb"|"bc4-r-unorm"|"bc4-r-snorm"|"bc5-rg-unorm"|"bc5-rg-snorm"|"bc6h-rgb-ufloat"|"bc6h-rgb-float"|"bc7-rgba-unorm"|"bc7-rgba-unorm-srgb"|"depth24unorm-stencil8"|"depth32float-stencil8";declare class GPUSampler implements GPUObjectBase{label:string|null;}declare interface GPUSamplerDescriptor extends GPUObjectDescriptorBase{addressModeU?:GPUAddressMode;addressModeV?:GPUAddressMode;addressModeW?:GPUAddressMode;magFilter?:GPUFilterMode;minFilter?:GPUFilterMode;mipmapFilter?:GPUFilterMode;lodMinClamp?:number;lodMaxClamp?:number;compare?:GPUCompareFunction;maxAnisotropy?:number;}declare type GPUAddressMode="clamp-to-edge"|"repeat"|"mirror-repeat";declare type GPUFilterMode="nearest"|"linear";declare type GPUCompareFunction=|"never"|"less"|"equal"|"less-equal"|"greater"|"not-equal"|"greater-equal"|"always";declare class GPUBindGroupLayout implements GPUObjectBase{label:string|null;}declare interface GPUBindGroupLayoutDescriptor extends GPUObjectDescriptorBase{entries:GPUBindGroupLayoutEntry[];}declare interface GPUBindGroupLayoutEntry{binding:number;visibility:GPUShaderStageFlags;buffer?:GPUBufferBindingLayout;sampler?:GPUSamplerBindingLayout;texture?:GPUTextureBindingLayout;storageTexture?:GPUStorageTextureBindingLayout;}declare type GPUShaderStageFlags=number;declare class GPUShaderStage{static VERTEX:0x1;static FRAGMENT:0x2;static COMPUTE:0x4;}declare interface GPUBufferBindingLayout{type?:GPUBufferBindingType;hasDynamicOffset?:boolean;minBindingSize?:number;}declare type GPUBufferBindingType="uniform"|"storage"|"read-only-storage";declare interface GPUSamplerBindingLayout{type?:GPUSamplerBindingType;}declare type GPUSamplerBindingType=|"filtering"|"non-filtering"|"comparison";declare interface GPUTextureBindingLayout{sampleType?:GPUTextureSampleType;viewDimension?:GPUTextureViewDimension;multisampled?:boolean;}declare type GPUTextureSampleType=|"float"|"unfilterable-float"|"depth"|"sint"|"uint";declare type GPUStorageTextureAccess="write-only";declare interface GPUStorageTextureBindingLayout{access:GPUStorageTextureAccess;format:GPUTextureFormat;viewDimension?:GPUTextureViewDimension;}declare class GPUBindGroup implements GPUObjectBase{label:string|null;}declare interface GPUBindGroupDescriptor extends GPUObjectDescriptorBase{layout:GPUBindGroupLayout;entries:GPUBindGroupEntry[];}declare type GPUBindingResource=|GPUSampler|GPUTextureView|GPUBufferBinding;declare interface GPUBindGroupEntry{binding:number;resource:GPUBindingResource;}declare interface GPUBufferBinding{buffer:GPUBuffer;offset?:number;size?:number;}declare class GPUPipelineLayout implements GPUObjectBase{label:string|null;}declare interface GPUPipelineLayoutDescriptor extends GPUObjectDescriptorBase{bindGroupLayouts:GPUBindGroupLayout[];}declare type GPUCompilationMessageType="error"|"warning"|"info";declare interface GPUCompilationMessage{readonly message:string;readonly type:GPUCompilationMessageType;readonly lineNum:number;readonly linePos:number;}declare interface GPUCompilationInfo{readonly messages:ReadonlyArray<GPUCompilationMessage>;}declare class GPUShaderModule implements GPUObjectBase{label:string|null;compilationInfo():Promise<GPUCompilationInfo>;}declare interface GPUShaderModuleDescriptor extends GPUObjectDescriptorBase{code:string;sourceMap?:any;}declare interface GPUPipelineDescriptorBase extends GPUObjectDescriptorBase{layout?:GPUPipelineLayout;}declare interface GPUPipelineBase{getBindGroupLayout(index:number):GPUBindGroupLayout;}declare interface GPUProgrammableStage{module:GPUShaderModule;entryPoint:string;}declare class GPUComputePipeline implements GPUObjectBase,GPUPipelineBase{label:string|null;getBindGroupLayout(index:number):GPUBindGroupLayout;}declare interface GPUComputePipelineDescriptor extends GPUPipelineDescriptorBase{compute:GPUProgrammableStage;}declare class GPURenderPipeline implements GPUObjectBase,GPUPipelineBase{label:string|null;getBindGroupLayout(index:number):GPUBindGroupLayout;}declare interface GPURenderPipelineDescriptor extends GPUPipelineDescriptorBase{vertex:GPUVertexState;primitive?:GPUPrimitiveState;depthStencil?:GPUDepthStencilState;multisample?:GPUMultisampleState;fragment?:GPUFragmentState;}declare type GPUPrimitiveTopology=|"point-list"|"line-list"|"line-strip"|"triangle-list"|"triangle-strip";declare interface GPUPrimitiveState{topology?:GPUPrimitiveTopology;stripIndexFormat?:GPUIndexFormat;frontFace?:GPUFrontFace;cullMode?:GPUCullMode;clampDepth?:boolean;}declare type GPUFrontFace="ccw"|"cw";declare type GPUCullMode="none"|"front"|"back";declare interface GPUMultisampleState{count?:number;mask?:number;alphaToCoverageEnabled?:boolean;}declare interface GPUFragmentState extends GPUProgrammableStage{targets:GPUColorTargetState[];}declare interface GPUColorTargetState{format:GPUTextureFormat;blend?:GPUBlendState;writeMask?:GPUColorWriteFlags;}declare interface GPUBlendState{color:GPUBlendComponent;alpha:GPUBlendComponent;}declare type GPUColorWriteFlags=number;declare class GPUColorWrite{static RED:0x1;static GREEN:0x2;static BLUE:0x4;static ALPHA:0x8;static ALL:0xF;}declare interface GPUBlendComponent{srcFactor:GPUBlendFactor;dstFactor:GPUBlendFactor;operation:GPUBlendOperation;}declare type GPUBlendFactor=|"zero"|"one"|"src"|"one-minus-src"|"src-alpha"|"one-minus-src-alpha"|"dst"|"one-minus-dst"|"dst-alpha"|"one-minus-dst-alpha"|"src-alpha-saturated"|"constant"|"one-minus-constant";declare type GPUBlendOperation=|"add"|"subtract"|"reverse-subtract"|"min"|"max";declare interface GPUDepthStencilState{format:GPUTextureFormat;depthWriteEnabled?:boolean;depthCompare?:GPUCompareFunction;stencilFront?:GPUStencilFaceState;stencilBack?:GPUStencilFaceState;stencilReadMask?:number;stencilWriteMask?:number;depthBias?:number;depthBiasSlopeScale?:number;depthBiasClamp?:number;}declare interface GPUStencilFaceState{compare?:GPUCompareFunction;failOp?:GPUStencilOperation;depthFailOp?:GPUStencilOperation;passOp?:GPUStencilOperation;}declare type GPUStencilOperation=|"keep"|"zero"|"replace"|"invert"|"increment-clamp"|"decrement-clamp"|"increment-wrap"|"decrement-wrap";declare type GPUIndexFormat="uint16"|"uint32";declare type GPUVertexFormat=|"uint8x2"|"uint8x4"|"sint8x2"|"sint8x4"|"unorm8x2"|"unorm8x4"|"snorm8x2"|"snorm8x4"|"uint16x2"|"uint16x4"|"sint16x2"|"sint16x4"|"unorm16x2"|"unorm16x4"|"snorm16x2"|"snorm16x4"|"float16x2"|"float16x4"|"float32"|"float32x2"|"float32x3"|"float32x4"|"uint32"|"uint32x2"|"uint32x3"|"uint32x4"|"sint32"|"sint32x2"|"sint32x3"|"sint32x4";declare type GPUVertexStepMode="vertex"|"instance";declare interface GPUVertexState extends GPUProgrammableStage{buffers?:(GPUVertexBufferLayout|null)[];}declare interface GPUVertexBufferLayout{arrayStride:number;stepMode?:GPUVertexStepMode;attributes:GPUVertexAttribute[];}declare interface GPUVertexAttribute{format:GPUVertexFormat;offset:number;shaderLocation:number;}declare class GPUCommandBuffer implements GPUObjectBase{label:string|null;readonly executionTime:Promise<number>;}declare interface GPUCommandBufferDescriptor extends GPUObjectDescriptorBase{}declare class GPUCommandEncoder implements GPUObjectBase{label:string|null;beginRenderPass(descriptor:GPURenderPassDescriptor):GPURenderPassEncoder;beginComputePass(descriptor?:GPUComputePassDescriptor,):GPUComputePassEncoder;copyBufferToBuffer(source:GPUBuffer,sourceOffset:number,destination:GPUBuffer,destinationOffset:number,size:number,):undefined;copyBufferToTexture(source:GPUImageCopyBuffer,destination:GPUImageCopyTexture,copySize:GPUExtent3D,):undefined;copyTextureToBuffer(source:GPUImageCopyTexture,destination:GPUImageCopyBuffer,copySize:GPUExtent3D,):undefined;copyTextureToTexture(source:GPUImageCopyTexture,destination:GPUImageCopyTexture,copySize:GPUExtent3D,):undefined;pushDebugGroup(groupLabel:string):undefined;popDebugGroup():undefined;insertDebugMarker(markerLabel:string):undefined;writeTimestamp(querySet:GPUQuerySet,queryIndex:number):undefined;resolveQuerySet(querySet:GPUQuerySet,firstQuery:number,queryCount:number,destination:GPUBuffer,destinationOffset:number,):undefined;finish(descriptor?:GPUCommandBufferDescriptor):GPUCommandBuffer;}declare interface GPUCommandEncoderDescriptor extends GPUObjectDescriptorBase{measureExecutionTime?:boolean;}declare interface GPUImageDataLayout{offset?:number;bytesPerRow?:number;rowsPerImage?:number;}declare interface GPUImageCopyBuffer extends GPUImageDataLayout{buffer:GPUBuffer;}declare interface GPUImageCopyTexture{texture:GPUTexture;mipLevel?:number;origin?:GPUOrigin3D;aspect?:GPUTextureAspect;}interface GPUProgrammablePassEncoder{setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsets?:number[],):undefined;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsetsData:Uint32Array,dynamicOffsetsDataStart:number,dynamicOffsetsDataLength:number,):undefined;pushDebugGroup(groupLabel:string):undefined;popDebugGroup():undefined;insertDebugMarker(markerLabel:string):undefined;}declare class GPUComputePassEncoder implements GPUObjectBase,GPUProgrammablePassEncoder{label:string|null;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsets?:number[],):undefined;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsetsData:Uint32Array,dynamicOffsetsDataStart:number,dynamicOffsetsDataLength:number,):undefined;pushDebugGroup(groupLabel:string):undefined;popDebugGroup():undefined;insertDebugMarker(markerLabel:string):undefined;setPipeline(pipeline:GPUComputePipeline):undefined;dispatch(x:number,y?:number,z?:number):undefined;dispatchIndirect(indirectBuffer:GPUBuffer,indirectOffset:number,):undefined;beginPipelineStatisticsQuery(querySet:GPUQuerySet,queryIndex:number,):undefined;endPipelineStatisticsQuery():undefined;writeTimestamp(querySet:GPUQuerySet,queryIndex:number):undefined;endPass():undefined;}declare interface GPUComputePassDescriptor extends GPUObjectDescriptorBase{}interface GPURenderEncoderBase{setPipeline(pipeline:GPURenderPipeline):undefined;setIndexBuffer(buffer:GPUBuffer,indexFormat:GPUIndexFormat,offset?:number,size?:number,):undefined;setVertexBuffer(slot:number,buffer:GPUBuffer,offset?:number,size?:number,):undefined;draw(vertexCount:number,instanceCount?:number,firstVertex?:number,firstInstance?:number,):undefined;drawIndexed(indexCount:number,instanceCount?:number,firstIndex?:number,baseVertex?:number,firstInstance?:number,):undefined;drawIndirect(indirectBuffer:GPUBuffer,indirectOffset:number):undefined;drawIndexedIndirect(indirectBuffer:GPUBuffer,indirectOffset:number,):undefined;}declare class GPURenderPassEncoder implements GPUObjectBase,GPUProgrammablePassEncoder,GPURenderEncoderBase{label:string|null;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsets?:number[],):undefined;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsetsData:Uint32Array,dynamicOffsetsDataStart:number,dynamicOffsetsDataLength:number,):undefined;pushDebugGroup(groupLabel:string):undefined;popDebugGroup():undefined;insertDebugMarker(markerLabel:string):undefined;setPipeline(pipeline:GPURenderPipeline):undefined;setIndexBuffer(buffer:GPUBuffer,indexFormat:GPUIndexFormat,offset?:number,size?:number,):undefined;setVertexBuffer(slot:number,buffer:GPUBuffer,offset?:number,size?:number,):undefined;draw(vertexCount:number,instanceCount?:number,firstVertex?:number,firstInstance?:number,):undefined;drawIndexed(indexCount:number,instanceCount?:number,firstIndex?:number,baseVertex?:number,firstInstance?:number,):undefined;drawIndirect(indirectBuffer:GPUBuffer,indirectOffset:number):undefined;drawIndexedIndirect(indirectBuffer:GPUBuffer,indirectOffset:number,):undefined;setViewport(x:number,y:number,width:number,height:number,minDepth:number,maxDepth:number,):undefined;setScissorRect(x:number,y:number,width:number,height:number,):undefined;setBlendConstant(color:GPUColor):undefined;setStencilReference(reference:number):undefined;beginOcclusionQuery(queryIndex:number):undefined;endOcclusionQuery():undefined;beginPipelineStatisticsQuery(querySet:GPUQuerySet,queryIndex:number,):undefined;endPipelineStatisticsQuery():undefined;writeTimestamp(querySet:GPUQuerySet,queryIndex:number):undefined;executeBundles(bundles:GPURenderBundle[]):undefined;endPass():undefined;}declare interface GPURenderPassDescriptor extends GPUObjectDescriptorBase{colorAttachments:GPURenderPassColorAttachment[];depthStencilAttachment?:GPURenderPassDepthStencilAttachment;occlusionQuerySet?:GPUQuerySet;}declare interface GPURenderPassColorAttachment{view:GPUTextureView;resolveTarget?:GPUTextureView;loadValue:GPULoadOp|GPUColor;storeOp?:GPUStoreOp;}declare interface GPURenderPassDepthStencilAttachment{view:GPUTextureView;depthLoadValue:GPULoadOp|number;depthStoreOp:GPUStoreOp;depthReadOnly?:boolean;stencilLoadValue:GPULoadOp|number;stencilStoreOp:GPUStoreOp;stencilReadOnly?:boolean;}declare type GPULoadOp="load";declare type GPUStoreOp="store"|"discard";declare class GPURenderBundle implements GPUObjectBase{label:string|null;}declare interface GPURenderBundleDescriptor extends GPUObjectDescriptorBase{}declare class GPURenderBundleEncoder implements GPUObjectBase,GPUProgrammablePassEncoder,GPURenderEncoderBase{label:string|null;draw(vertexCount:number,instanceCount?:number,firstVertex?:number,firstInstance?:number,):undefined;drawIndexed(indexCount:number,instanceCount?:number,firstIndex?:number,baseVertex?:number,firstInstance?:number,):undefined;drawIndexedIndirect(indirectBuffer:GPUBuffer,indirectOffset:number,):undefined;drawIndirect(indirectBuffer:GPUBuffer,indirectOffset:number):undefined;insertDebugMarker(markerLabel:string):undefined;popDebugGroup():undefined;pushDebugGroup(groupLabel:string):undefined;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsets?:number[],):undefined;setBindGroup(index:number,bindGroup:GPUBindGroup,dynamicOffsetsData:Uint32Array,dynamicOffsetsDataStart:number,dynamicOffsetsDataLength:number,):undefined;setIndexBuffer(buffer:GPUBuffer,indexFormat:GPUIndexFormat,offset?:number,size?:number,):undefined;setPipeline(pipeline:GPURenderPipeline):undefined;setVertexBuffer(slot:number,buffer:GPUBuffer,offset?:number,size?:number,):undefined;finish(descriptor?:GPURenderBundleDescriptor):GPURenderBundle;}declare interface GPURenderPassLayout extends GPUObjectDescriptorBase{colorFormats:GPUTextureFormat[];depthStencilFormat?:GPUTextureFormat;sampleCount?:number;}declare interface GPURenderBundleEncoderDescriptor extends GPURenderPassLayout{depthReadOnly?:boolean;stencilReadOnly?:boolean;}declare class GPUQueue implements GPUObjectBase{label:string|null;submit(commandBuffers:GPUCommandBuffer[]):undefined;onSubmittedWorkDone():Promise<undefined>;writeBuffer(buffer:GPUBuffer,bufferOffset:number,data:BufferSource,dataOffset?:number,size?:number,):undefined;writeTexture(destination:GPUImageCopyTexture,data:BufferSource,dataLayout:GPUImageDataLayout,size:GPUExtent3D,):undefined;}declare class GPUQuerySet implements GPUObjectBase{label:string|null;destroy():undefined;}declare interface GPUQuerySetDescriptor extends GPUObjectDescriptorBase{type:GPUQueryType;count:number;pipelineStatistics?:GPUPipelineStatisticName[];}declare type GPUQueryType="occlusion"|"pipeline-statistics"|"timestamp";declare type GPUPipelineStatisticName=|"vertex-shader-invocations"|"clipper-invocations"|"clipper-primitives-out"|"fragment-shader-invocations"|"compute-shader-invocations";declare type GPUDeviceLostReason="destroyed";declare interface GPUDeviceLostInfo{readonly reason:GPUDeviceLostReason|undefined;readonly message:string;}declare type GPUErrorFilter="out-of-memory"|"validation";declare class GPUOutOfMemoryError{constructor();}declare class GPUValidationError{constructor(message:string);readonly message:string;}declare type GPUError=GPUOutOfMemoryError|GPUValidationError;declare class GPUUncapturedErrorEvent extends Event{constructor(type:string,gpuUncapturedErrorEventInitDict:GPUUncapturedErrorEventInit,);readonly error:GPUError;}declare interface GPUUncapturedErrorEventInit extends EventInit{error?:GPUError;}declare interface GPUColorDict{r:number;g:number;b:number;a:number;}declare type GPUColor=number[]|GPUColorDict;declare interface GPUOrigin3DDict{x?:number;y?:number;z?:number;}declare type GPUOrigin3D=number[]|GPUOrigin3DDict;declare interface GPUExtent3DDict{width:number;height?:number;depthOrArrayLayers?:number;}declare type GPUExtent3D=number[]|GPUExtent3DDict;/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
interface CloseEventInit extends EventInit{code?:number;reason?:string;wasClean?:boolean;}declare class CloseEvent extends Event{constructor(type:string,eventInitDict?:CloseEventInit);readonly code:number;readonly reason:string;readonly wasClean:boolean;}interface WebSocketEventMap{close:CloseEvent;error:Event;message:MessageEvent;open:Event;}declare class WebSocket extends EventTarget{constructor(url:string,protocols?:string|string[]);static readonly CLOSED:number;static readonly CLOSING:number;static readonly CONNECTING:number;static readonly OPEN:number;binaryType:BinaryType;readonly bufferedAmount:number;readonly extensions:string;onclose:((this:WebSocket,ev:CloseEvent)=>any)|null;onerror:((this:WebSocket,ev:Event|ErrorEvent)=>any)|null;onmessage:((this:WebSocket,ev:MessageEvent)=>any)|null;onopen:((this:WebSocket,ev:Event)=>any)|null;readonly protocol:string;readonly readyState:number;readonly url:string;close(code?:number,reason?:string):void;send(data:string|ArrayBufferLike|Blob|ArrayBufferView):void;readonly CLOSED:number;readonly CLOSING:number;readonly CONNECTING:number;readonly OPEN:number;addEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;}type BinaryType="arraybuffer"|"blob";/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
interface Storage{readonly length:number;clear():void;getItem(key:string):string|null;key(index:number):string|null;removeItem(key:string):void;setItem(key:string,value:string):void;[name:string]:any;}declare var Storage:{prototype:Storage;new():Storage;};/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare var crypto:Crypto;interface Algorithm{name:string;}interface KeyAlgorithm{name:string;}type AlgorithmIdentifier=string|Algorithm;type HashAlgorithmIdentifier=AlgorithmIdentifier;type KeyType="private"|"public"|"secret";type KeyUsage=|"decrypt"|"deriveBits"|"deriveKey"|"encrypt"|"sign"|"unwrapKey"|"verify"|"wrapKey";type KeyFormat="jwk"|"pkcs8"|"raw"|"spki";type NamedCurve=string;interface RsaOtherPrimesInfo{d?:string;r?:string;t?:string;}interface JsonWebKey{alg?:string;crv?:string;d?:string;dp?:string;dq?:string;e?:string;ext?:boolean;k?:string;key_ops?:string[];kty?:string;n?:string;oth?:RsaOtherPrimesInfo[];p?:string;q?:string;qi?:string;use?:string;x?:string;y?:string;}interface AesCbcParams extends Algorithm{iv:BufferSource;}interface HmacKeyGenParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface EcKeyGenParams extends Algorithm{namedCurve:NamedCurve;}interface EcImportParams extends Algorithm{namedCurve:NamedCurve;}interface EcdsaParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface RsaHashedImportParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface RsaHashedKeyGenParams extends RsaKeyGenParams{hash:HashAlgorithmIdentifier;}interface RsaKeyGenParams extends Algorithm{modulusLength:number;publicExponent:Uint8Array;}interface RsaPssParams extends Algorithm{saltLength:number;}interface RsaOaepParams extends Algorithm{label?:Uint8Array;}interface HmacImportParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface RsaHashedImportParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface EcKeyAlgorithm extends KeyAlgorithm{namedCurve:NamedCurve;}interface HmacKeyAlgorithm extends KeyAlgorithm{hash:KeyAlgorithm;length:number;}interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm{hash:KeyAlgorithm;}interface RsaKeyAlgorithm extends KeyAlgorithm{modulusLength:number;publicExponent:Uint8Array;}interface HkdfParams extends Algorithm{hash:HashAlgorithmIdentifier;info:BufferSource;salt:BufferSource;}interface Pbkdf2Params extends Algorithm{hash:HashAlgorithmIdentifier;iterations:number;salt:BufferSource;}interface AesDerivedKeyParams extends Algorithm{length:number;}interface EcdhKeyDeriveParams extends Algorithm{public:CryptoKey;}interface AesKeyGenParams extends Algorithm{length:number;}interface AesKeyAlgorithm extends KeyAlgorithm{length:number;}interface CryptoKey{readonly algorithm:KeyAlgorithm;readonly extractable:boolean;readonly type:KeyType;readonly usages:KeyUsage[];}declare var CryptoKey:{prototype:CryptoKey;new():CryptoKey;};interface CryptoKeyPair{privateKey:CryptoKey;publicKey:CryptoKey;}declare var CryptoKeyPair:{prototype:CryptoKeyPair;new():CryptoKeyPair;};interface SubtleCrypto{generateKey(algorithm:RsaHashedKeyGenParams|EcKeyGenParams,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKeyPair>;generateKey(algorithm:AesKeyGenParams|HmacKeyGenParams,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKey>;generateKey(algorithm:AlgorithmIdentifier,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKeyPair|CryptoKey>;importKey(format:"jwk",keyData:JsonWebKey,algorithm:|AlgorithmIdentifier|HmacImportParams|RsaHashedImportParams|EcImportParams,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKey>;importKey(format:Exclude<KeyFormat,"jwk">,keyData:BufferSource,algorithm:|AlgorithmIdentifier|HmacImportParams|RsaHashedImportParams|EcImportParams,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKey>;exportKey(format:"jwk",key:CryptoKey):Promise<JsonWebKey>;exportKey(format:Exclude<KeyFormat,"jwk">,key:CryptoKey,):Promise<ArrayBuffer>;sign(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams,key:CryptoKey,data:BufferSource,):Promise<ArrayBuffer>;verify(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams,key:CryptoKey,signature:BufferSource,data:BufferSource,):Promise<boolean>;digest(algorithm:AlgorithmIdentifier,data:BufferSource,):Promise<ArrayBuffer>;encrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCbcParams,key:CryptoKey,data:BufferSource,):Promise<ArrayBuffer>;decrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCbcParams,key:CryptoKey,data:BufferSource,):Promise<ArrayBuffer>;deriveBits(algorithm:|AlgorithmIdentifier|HkdfParams|Pbkdf2Params|EcdhKeyDeriveParams,baseKey:CryptoKey,length:number,):Promise<ArrayBuffer>;deriveKey(algorithm:AlgorithmIdentifier|HkdfParams|Pbkdf2Params,baseKey:CryptoKey,derivedKeyType:|AlgorithmIdentifier|AesDerivedKeyParams|HmacImportParams|HkdfParams|Pbkdf2Params,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKey>;wrapKey(format:KeyFormat,key:CryptoKey,wrappingKey:CryptoKey,wrapAlgorithm:AlgorithmIdentifier|RsaOaepParams,):Promise<ArrayBuffer>;unwrapKey(format:KeyFormat,wrappedKey:BufferSource,unwrappingKey:CryptoKey,unwrapAlgorithm:|AlgorithmIdentifier|RsaOaepParams|AesCbcParams,unwrappedKeyAlgorithm:|AlgorithmIdentifier|RsaHashedImportParams|HmacImportParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[],):Promise<CryptoKey>;}declare interface Crypto{readonly subtle:SubtleCrypto;getRandomValues<
T extends|Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|null,>(array:T,):T;randomUUID():string;}declare var SubtleCrypto:{prototype:SubtleCrypto;new():SubtleCrypto;};/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
interface BroadcastChannelEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface BroadcastChannel extends EventTarget{readonly name:string;onmessage:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;onmessageerror:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any):void;addEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;}declare var BroadcastChannel:{prototype:BroadcastChannel;new(name:string):BroadcastChannel;};/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
declare namespace Deno{export interface NetAddr{transport:"tcp"|"udp";hostname:string;port:number;}export interface UnixAddr{transport:"unix"|"unixpacket";path:string;}export type Addr=NetAddr|UnixAddr;export interface Listener extends AsyncIterable<Conn>{accept():Promise<Conn>;close():void;readonly addr:Addr;readonly rid:number;[Symbol.asyncIterator]():AsyncIterableIterator<Conn>;}export interface TlsListener extends Listener,AsyncIterable<TlsConn>{accept():Promise<TlsConn>;[Symbol.asyncIterator]():AsyncIterableIterator<TlsConn>;}export interface Conn extends Reader,Writer,Closer{readonly localAddr:Addr;readonly remoteAddr:Addr;readonly rid:number;closeWrite():Promise<void>;}export interface TlsHandshakeInfo{}export interface TlsConn extends Conn{handshake():Promise<TlsHandshakeInfo>;}export interface ListenOptions{port:number;hostname?:string;}export function listen(options:ListenOptions&{transport?:"tcp"},):Listener;export interface ListenTlsOptions extends ListenOptions{certFile:string;keyFile:string;transport?:"tcp";}export function listenTls(options:ListenTlsOptions):TlsListener;export interface ConnectOptions{port:number;hostname?:string;transport?:"tcp";}export function connect(options:ConnectOptions):Promise<Conn>;export interface ConnectTlsOptions{port:number;hostname?:string;certFile?:string;caCerts?:string[];}export function connectTls(options:ConnectTlsOptions):Promise<TlsConn>;export interface StartTlsOptions{hostname?:string;caCerts?:string[];}export function startTls(conn:Conn,options?:StartTlsOptions,):Promise<TlsConn>;export function shutdown(rid:number):Promise<void>;}/// <reference no-default-lib="true" />
/// <reference lib="esnext" />
/// <reference lib="deno.console" />
/// <reference lib="deno.url" />
/// <reference lib="deno.web" />
/// <reference lib="deno.fetch" />
/// <reference lib="deno.websocket" />
/// <reference lib="deno.crypto" />
/// <reference lib="deno.broadcast_channel" />
declare namespace WebAssembly{export class CompileError extends Error{constructor();}export class Global{constructor(descriptor:GlobalDescriptor,v?:any);value:any;valueOf():any;}export class Instance{constructor(module:Module,importObject?:Imports);readonly exports:Exports;}export class LinkError extends Error{constructor();}export class Memory{constructor(descriptor:MemoryDescriptor);readonly buffer:ArrayBuffer|SharedArrayBuffer;grow(delta:number):number;}export class Module{constructor(bytes:BufferSource);static customSections(moduleObject:Module,sectionName:string,):ArrayBuffer[];static exports(moduleObject:Module):ModuleExportDescriptor[];static imports(moduleObject:Module):ModuleImportDescriptor[];}export class RuntimeError extends Error{constructor();}export class Table{constructor(descriptor:TableDescriptor);readonly length:number;get(index:number):Function|null;grow(delta:number):number;set(index:number,value:Function|null):void;}export interface GlobalDescriptor{mutable?:boolean;value:ValueType;}export interface MemoryDescriptor{initial:number;maximum?:number;shared?:boolean;}export interface ModuleExportDescriptor{kind:ImportExportKind;name:string;}export interface ModuleImportDescriptor{kind:ImportExportKind;module:string;name:string;}export interface TableDescriptor{element:TableKind;initial:number;maximum?:number;}export interface WebAssemblyInstantiatedSource{instance:Instance;module:Module;}export type ImportExportKind="function"|"global"|"memory"|"table";export type TableKind="anyfunc";export type ValueType="f32"|"f64"|"i32"|"i64";export type ExportValue=Function|Global|Memory|Table;export type Exports=Record<string,ExportValue>;export type ImportValue=ExportValue|number;export type ModuleImports=Record<string,ImportValue>;export type Imports=Record<string,ModuleImports>;export function compile(bytes:BufferSource):Promise<Module>;export function compileStreaming(source:Response|Promise<Response>,):Promise<Module>;export function instantiate(bytes:BufferSource,importObject?:Imports,):Promise<WebAssemblyInstantiatedSource>;export function instantiate(moduleObject:Module,importObject?:Imports,):Promise<Instance>;export function instantiateStreaming(response:Response|PromiseLike<Response>,importObject?:Imports,):Promise<WebAssemblyInstantiatedSource>;export function validate(bytes:BufferSource):boolean;}declare function setTimeout(cb:(...args:any[])=>void,delay?:number,...args:any[]):number;declare function setInterval(cb:(...args:any[])=>void,delay?:number,...args:any[]):number;declare function clearInterval(id?:number):void;declare function clearTimeout(id?:number):void;interface VoidFunction{():void;}declare function queueMicrotask(func:VoidFunction):void;declare function dispatchEvent(event:Event):boolean;interface DOMStringList{readonly length:number;contains(string:string):boolean;item(index:number):string|null;[index:number]:string;}type BufferSource=ArrayBufferView|ArrayBuffer;declare var console:Console;interface ErrorEventInit extends EventInit{message?:string;filename?:string;lineno?:number;colno?:number;error?:any;}declare class ErrorEvent extends Event{readonly message:string;readonly filename:string;readonly lineno:number;readonly colno:number;readonly error:any;constructor(type:string,eventInitDict?:ErrorEventInit);}interface AbstractWorkerEventMap{"error":ErrorEvent;}interface WorkerEventMap extends AbstractWorkerEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface WorkerOptions{type?:"classic"|"module";name?:string;}declare class Worker extends EventTarget{onerror?:(e:ErrorEvent)=>void;onmessage?:(e:MessageEvent)=>void;onmessageerror?:(e:MessageEvent)=>void;constructor(specifier:string|URL,options?:WorkerOptions,);postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:StructuredSerializeOptions):void;addEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions,):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions,):void;removeEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|EventListenerOptions,):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions,):void;terminate():void;}declare type PerformanceEntryList=PerformanceEntry[];declare class Performance{constructor();clearMarks(markName?:string):void;clearMeasures(measureName?:string):void;getEntries():PerformanceEntryList;getEntriesByName(name:string,type?:string):PerformanceEntryList;getEntriesByType(type:string):PerformanceEntryList;mark(markName:string,options?:PerformanceMarkOptions):PerformanceMark;measure(measureName:string,options?:PerformanceMeasureOptions,):PerformanceMeasure;measure(measureName:string,startMark?:string,endMark?:string,):PerformanceMeasure;now():number;}declare var performance:Performance;declare interface PerformanceMarkOptions{detail?:any;startTime?:number;}declare interface PerformanceMeasureOptions{detail?:any;start?:string|number;duration?:number;end?:string|number;}declare class PerformanceEntry{readonly duration:number;readonly entryType:string;readonly name:string;readonly startTime:number;toJSON():any;}declare class PerformanceMark extends PerformanceEntry{readonly detail:any;readonly entryType:"mark";constructor(name:string,options?:PerformanceMarkOptions);}declare class PerformanceMeasure extends PerformanceEntry{readonly detail:any;readonly entryType:"measure";}declare interface CustomEventInit<T=any>extends EventInit{detail?:T;}declare class CustomEvent<T=any>extends Event{constructor(typeArg:string,eventInitDict?:CustomEventInit<T>);readonly detail:T;}interface ErrorConstructor{captureStackTrace(error:Object,constructor?:Function):void;}/// <reference no-default-lib="true" />
/// <reference lib="deno.ns" />
/// <reference lib="deno.shared_globals" />
/// <reference lib="deno.webgpu" />
/// <reference lib="deno.webstorage" />
/// <reference lib="esnext" />
declare class Window extends EventTarget{new():Window;readonly window:Window&typeof globalThis;readonly self:Window&typeof globalThis;onload:((this:Window,ev:Event)=>any)|null;onunload:((this:Window,ev:Event)=>any)|null;close:()=>void;readonly closed:boolean;alert:(message?:string)=>void;confirm:(message?:string)=>boolean;prompt:(message?:string,defaultValue?:string)=>string|null;Deno:typeof Deno;Navigator:typeof Navigator;navigator:Navigator;Location:typeof Location;location:Location;localStorage:Storage;sessionStorage:Storage;}declare var window:Window&typeof globalThis;declare var self:Window&typeof globalThis;declare var onload:((this:Window,ev:Event)=>any)|null;declare var onunload:((this:Window,ev:Event)=>any)|null;declare var localStorage:Storage;declare var sessionStorage:Storage;declare class Navigator{constructor();readonly gpu:GPU;readonly hardwareConcurrency:number;}declare var navigator:Navigator;declare function alert(message?:string):void;declare function confirm(message?:string):boolean;declare function prompt(message?:string,defaultValue?:string):string|null;declare function addEventListener(type:string,callback:EventListenerOrEventListenerObject|null,options?:boolean|AddEventListenerOptions|undefined,):void;declare function removeEventListener(type:string,callback:EventListenerOrEventListenerObject|null,options?:boolean|EventListenerOptions|undefined,):void;declare class Location{constructor();readonly ancestorOrigins:DOMStringList;hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;pathname:string;port:string;protocol:string;search:string;assign(url:string):void;reload():void;reload(forcedReload:boolean):void;replace(url:string):void;}declare var location:Location;`
